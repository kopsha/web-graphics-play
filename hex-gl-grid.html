<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hex-Square Pixel Grid</title>
<style>
  body { margin: 0; background: black; overflow: hidden; color: white; font-family: monospace; }
  #fps { position: absolute; top: 10px; left: 10px; font-size: 16px; }
</style>
</head>
<body>
<div id="fps">FPS: 0</div>
<canvas id="glCanvas"></canvas>

<script>
const canvas = document.getElementById('glCanvas');
const fpsLabel = document.getElementById('fps');
const gl = canvas.getContext('webgl2');
if (!gl) { alert('WebGL 2 not supported'); }

// Resize canvas
function resizeCanvas() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
  gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// Vertex shader
const vertexSrc = `#version 300 es
layout(location=0) in vec2 a_position;
void main() {
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;

// Fragment shader
const fragmentSrc = `#version 300 es
precision highp float;
uniform vec2 u_resolution;
uniform float u_time;
uniform float u_pixelSize;
uniform float u_gap;
out vec4 outColor;
void main() {
    vec2 frag = gl_FragCoord.xy;
    float cellSize = u_pixelSize + u_gap;
    float row = floor(frag.y / cellSize);
    float xOffset = mod(row,2.0) * (cellSize * 0.5);
    vec2 shifted = vec2(frag.x + xOffset, frag.y);
    vec2 cell = floor(shifted / cellSize);
    vec2 cellPos = mod(shifted, cellSize);
    if(cellPos.x >= u_pixelSize || cellPos.y >= u_pixelSize){
        outColor = vec4(0.0,0.0,0.0,1.0);
        return;
    }
    vec2 gridSize = u_resolution / cellSize;
    vec2 uv = cell / gridSize;
    vec3 color = 0.5 + 0.5 * cos(u_time + uv.xyx + vec3(0.0,2.0,4.0));
    outColor = vec4(color,1.0);
}`;

// Compile shader helper
function compileShader(src, type){
    const sh = gl.createShader(type);
    gl.shaderSource(sh, src);
    gl.compileShader(sh);
    if(!gl.getShaderParameter(sh, gl.COMPILE_STATUS)){
        console.error(gl.getShaderInfoLog(sh));
    }
    return sh;
}

// Link program
const vs = compileShader(vertexSrc, gl.VERTEX_SHADER);
const fs = compileShader(fragmentSrc, gl.FRAGMENT_SHADER);
const program = gl.createProgram();
gl.attachShader(program, vs);
gl.attachShader(program, fs);
gl.linkProgram(program);
if(!gl.getProgramParameter(program, gl.LINK_STATUS)){
    console.error(gl.getProgramInfoLog(program));
}
gl.useProgram(program);

// Fullscreen quad
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
    -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1
]), gl.STATIC_DRAW);
gl.enableVertexAttribArray(0);
gl.vertexAttribPointer(0,2,gl.FLOAT,false,0,0);

// Uniform locations
const uResolution = gl.getUniformLocation(program,'u_resolution');
const uTime = gl.getUniformLocation(program,'u_time');
const uPixelSize = gl.getUniformLocation(program,'u_pixelSize');
const uGap = gl.getUniformLocation(program,'u_gap');

// Initial parameters
let pixelSize = 20;
let gap = 4;

// Keyboard controls
window.addEventListener('keydown', e => {
    if(e.key === '+') pixelSize += 1;
    if(e.key === '-') pixelSize = Math.max(1,pixelSize-1);
    if(e.key === '*') gap += 1;
    if(e.key === '=') gap = Math.max(0,gap-1);
});

// FPS counter
let lastFpsUpdate = performance.now();
let frames = 0;

// Render loop
function render(now){
    now *= 0.001; // seconds
    frames++;
    if(now - lastFpsUpdate >= 1.0){
        fpsLabel.textContent = 'FPS: ' + frames;
        frames = 0;
        lastFpsUpdate = now;
    }

    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.uniform2f(uResolution, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.uniform1f(uTime, now);
    gl.uniform1f(uPixelSize, pixelSize);
    gl.uniform1f(uGap, gap);

    gl.drawArrays(gl.TRIANGLES,0,6);
    requestAnimationFrame(render);
}
requestAnimationFrame(render);
</script>
</body>
</html>

